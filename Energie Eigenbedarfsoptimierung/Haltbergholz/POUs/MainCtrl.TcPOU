<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MainCtrl" Id="{6fe93612-4e2b-441c-92a1-cb9f7886abad}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MainCtrl
VAR
    fbReadOpData: FB_ModbusCon := (
                    sInverterIPAddr := '127.0.0.1',
                    nInverterTCPPort := 5502,
                    nInverterUnitID := 16#01,
                    nMeterUnitID := 16#C8,
                    tConnectionTimeout := T#10S,
                    tConnectionCoolDown := T#10S);

    // Load control 1
    ipLoad: I_LoadCtrl;

    aInverterHistoryPower: ARRAY[1..nSamplesMovingAverage] OF REAL;
    nInverterHistoryCursor: INT;
    stInverterPower: ST_CtrlDataPower;

    aMeterHistoryPowerL1: ARRAY[1..nSamplesMovingAverage] OF REAL;
    nMeterHistoryCursorPowerL1: INT;
    aMeterHistoryPowerL2: ARRAY[1..nSamplesMovingAverage] OF REAL;
    nMeterHistoryCursorPowerL2: INT;
    aMeterHistoryPowerL3: ARRAY[1..nSamplesMovingAverage] OF REAL;
    nMeterHistoryCursorPowerL3: INT;
    stMeterPower: ST_CtrlDataPower;

    fbStorageIsCharging: FB_SchmittTrigger;

    // Actual power feed to grid (>0: feed to grid, <0: draw from grid)
    stSurplusPower: ST_CtrlDataPower;
    // Surplus available at Phase L1
    fbSurplusAvailableL1: FB_SchmittTrigger;
    // Surplus available at Phase L2
    fbSurplusAvailableL2: FB_SchmittTrigger;
    // Surplus available at Phase L3
    fbSurplusAvailableL3: FB_SchmittTrigger;

    // Minimum amount of power feed to grid must be exceeded to show as surplus (>=0W)
    {attribute 'hide'}
    _stSurplusPowerMinimum: ST_CtrlDataPower;
END_VAR
VAR_TEMP
    fInverterPower: REAL;
END_VAR
VAR CONSTANT
    nSamplesMovingAverage: INT := 3;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbReadOpData();

// Inverter
IF fbReadOpData.stInverter.bOpDataIsUpdated THEN
    fInverterPower := F_MovingAverage(fIn := fbReadOpData.stInverter.fPower, aHisotry := aInverterHistoryPower, nCursor := nInverterHistoryCursor);
    stInverterPower.fPowerL1 := fInverterPower / 3;
    stInverterPower.fPowerL2 := fInverterPower / 3;
    stInverterPower.fPowerL3 := fInverterPower / 3;
END_IF

// Meter
IF fbReadOpData.stMeter.bOpDataIsUpdated THEN
    stMeterPower.fPowerL1 := F_MovingAverage(fIn := fbReadOpData.stMeter.fPowerL1, aHisotry := aMeterHistoryPowerL1, nCursor := nMeterHistoryCursorPowerL1);
    stMeterPower.fPowerL2 := F_MovingAverage(fIn := fbReadOpData.stMeter.fPowerL2, aHisotry := aMeterHistoryPowerL2, nCursor := nMeterHistoryCursorPowerL2);
    stMeterPower.fPowerL3 := F_MovingAverage(fIn := fbReadOpData.stMeter.fPowerL3, aHisotry := aMeterHistoryPowerL3, nCursor := nMeterHistoryCursorPowerL3);
END_IF

// Storage
IF fbReadOpData.stStorage.nStateOfCharge > 75 THEN
    fbStorageIsCharging.tFallThreshold := T#5M;
    fbStorageIsCharging.tRiseThreshold := T#2M;
    fbStorageIsCharging.nLimitOscillations := 3;
ELSE
    fbStorageIsCharging.tFallThreshold := T#2M;
    fbStorageIsCharging.tRiseThreshold := T#2M;
    fbStorageIsCharging.nLimitOscillations := 3;
END_IF
fbStorageIsCharging(bIn := fbReadOpData.stStorage.eState = E_StorageChargeState.charging);

// Surplus per phase
IF fbReadOpData.stMeter.bOpDataIsUpdated THEN
    // Reverse sign of power measurements (>0: feed to grid, <0: draw from grid)
    stSurplusPower.fPowerL1 := stMeterPower.fPowerL1 * -1;
    stSurplusPower.fPowerL2 := stMeterPower.fPowerL2 * -1;
    stSurplusPower.fPowerL3 := stMeterPower.fPowerL3 * -1;

    // Generate setpoint for each load
    ipLoad.stLoadSetpoint := GenerateSetpoint(stLoadPowerMaximum := ipLoad.stPowerMaximum);

    // Detect change between power feed and draw to grid
    fbSurplusAvailableL1.bIn := stSurplusPower.fPowerL1 >= stSurplusPowerMinimum.fPowerL1;
    fbSurplusAvailableL2.bIn := stSurplusPower.fPowerL2 >= stSurplusPowerMinimum.fPowerL2;
    fbSurplusAvailableL3.bIn := stSurplusPower.fPowerL3 >= stSurplusPowerMinimum.fPowerL3;
END_IF

fbSurplusAvailableL1();
fbSurplusAvailableL2();
fbSurplusAvailableL3();

IF fbSurplusAvailableL1.bOut THEN
    
    IF ipLoad.bReady THEN
        ipLoad.PowerUp(ePhase := E_PhaseSelect.L1);
    ELSE
        ipLoad.PowerDown(ePhase := E_PhaseSelect.L1);
    END_IF
ELSE
    ipLoad.stLoadSetpoint.nLoadSetpointL1 := 0;
END_IF]]></ST>
    </Implementation>
    <Method Name="GenerateSetpoint" Id="{7c4d6669-3131-49f9-ba82-a86fe0f83fc7}">
      <Declaration><![CDATA[// Generate ST_CtrlDataSetpoint based on ST_CtrlDataPower of the load and the current stSurplusPower 
METHOD PRIVATE GenerateSetpoint : REFERENCE TO ST_CtrlDataSetpoint
VAR_INPUT
    stLoadPowerMaximum: REFERENCE TO ST_CtrlDataPower;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GenerateSetpoint.nLoadSetpointL1 := REAL_TO_USINT(LIMIT(0, stSurplusPower.fPowerL1 / stLoadPowerMaximum.fPowerL1, 1) * 255);
GenerateSetpoint.nLoadSetpointL2 := REAL_TO_USINT(LIMIT(0, stSurplusPower.fPowerL2 / stLoadPowerMaximum.fPowerL2, 1) * 255);
GenerateSetpoint.nLoadSetpointL3 := REAL_TO_USINT(LIMIT(0, stSurplusPower.fPowerL3 / stLoadPowerMaximum.fPowerL3, 1) * 255);
]]></ST>
      </Implementation>
    </Method>
    <Property Name="nSurplusPowerLimitOscillations" Id="{f3c81810-4901-4d49-a22a-30f4488568b9}">
      <Declaration><![CDATA[PROPERTY nSurplusPowerLimitOscillations : INT]]></Declaration>
      <Get Name="Get" Id="{e0da4793-488d-4e04-8881-a9c077fad17f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{924a4907-d087-4023-9314-1c67bbb65a64}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[fbSurplusAvailableL1.nLimitOscillations := nSurplusPowerLimitOscillations;
fbSurplusAvailableL2.nLimitOscillations := nSurplusPowerLimitOscillations;
fbSurplusAvailableL3.nLimitOscillations := nSurplusPowerLimitOscillations;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="stSurplusPowerMinimum" Id="{175349a6-cc75-4297-93d3-72e2c0f8e189}">
      <Declaration><![CDATA[// Minimum amount of power feed to grid must be exceeded to show as surplus (>=0W)s
{attribute 'monitoring' := 'call'}
PROPERTY stSurplusPowerMinimum : REFERENCE TO ST_CtrlDataPower]]></Declaration>
      <Get Name="Get" Id="{f861fbe1-0622-4ac5-abda-012686bbc051}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[stSurplusPowerMinimum REF= _stSurplusPowerMinimum;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{cd443d34-2d92-476d-8b99-4375c574c436}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_stSurplusPowerMinimum.fPowerL1 := stSurplusPowerMinimum.fPowerL1;
_stSurplusPowerMinimum.fPowerL2 := stSurplusPowerMinimum.fPowerL2;
_stSurplusPowerMinimum.fPowerL3 := stSurplusPowerMinimum.fPowerL3;

RETURN;

IF stSurplusPowerMinimum.fPowerL1 >= 0 THEN
    _stSurplusPowerMinimum.fPowerL1 := stSurplusPowerMinimum.fPowerL1;
ELSE
    _stSurplusPowerMinimum.fPowerL1 := 0;
END_IF
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="tSurplusPowerFallThreshold" Id="{20784289-b644-407f-aacb-7105532aa7d7}">
      <Declaration><![CDATA[PROPERTY tSurplusPowerFallThreshold : TIME]]></Declaration>
      <Get Name="Get" Id="{04bf4f41-f64f-4417-9a94-26c942e808fb}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{9b3fe5ab-1bab-4d8c-8162-3f6fc92bbf11}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[fbSurplusAvailableL1.tFallThreshold := tSurplusPowerFallThreshold;
fbSurplusAvailableL2.tFallThreshold := tSurplusPowerFallThreshold;
fbSurplusAvailableL3.tFallThreshold := tSurplusPowerFallThreshold;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="tSurplusPowerRiseThreshold" Id="{7f1592cf-e52c-47be-8922-7f9ed56e9c5b}">
      <Declaration><![CDATA[PROPERTY tSurplusPowerRiseThreshold : TIME]]></Declaration>
      <Get Name="Get" Id="{e39f2568-10c6-4156-aa6b-9ea17261ebd2}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{7b1406ab-109f-4d94-865a-1e30cdbffe9b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[fbSurplusAvailableL1.tRiseThreshold := tSurplusPowerRiseThreshold;
fbSurplusAvailableL2.tRiseThreshold := tSurplusPowerRiseThreshold;
fbSurplusAvailableL3.tRiseThreshold := tSurplusPowerRiseThreshold;
]]></ST>
        </Implementation>
      </Set>
    </Property>
  </POU>
</TcPlcObject>