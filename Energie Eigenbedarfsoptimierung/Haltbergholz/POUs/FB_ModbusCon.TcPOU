<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_ModbusCon" Id="{43065017-eb91-4d51-b9c6-b54abe313361}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_ModbusCon
VAR_INPUT
    bEnable: BOOL;
END_VAR
VAR_OUTPUT
    // Operating data from inverter
    stInverter: ST_OpDataInverter;
    // Operating data from meter
    stMeter: ST_OpDataMeter;
    // Operating data from storage
    stStorage: ST_OpDataStorage;
    // Connection is ready and not locked out
    bReady: BOOL;
END_VAR
VAR
    _sInverterIPAddr: STRING;
    _nInverterTCPPort: UINT;
    _nInverterUnitID: BYTE;
    _nMeterUnitID: BYTE;
    _tConnectionTimeout: TIME;
    _tConnectionCoolDown: TIME;

    // Modbus connection to read registers
    fbReadRegister: FB_MBReadRegs;
    // Connection cooldown timeout between requests
    fbConnectionCoolDown: TOF;

    // Register data of inverter
    stInverterRegisterData: ST_RegMapInverter;
    // Register data of meter
    stMeterRegisterData: ST_RegMapMeter;
    // Register data of storage
    stStorageRegisterData: ST_RegMapStorage;

    // Number of current tried countermeasures after modbus connection error
    nConnectionCountermeasure: INT;
    // Number of current tried countermeasures after modbus request error regarding inverter
    nInverterCountermeasure: INT;
    // Number of current tried countermeasures after modbus request error regarding meter
    nMeterCountermeasure: INT;
    // Number of current tried countermeasures after modbus request error regarding storage
    nStorageCountermeasure: INT;

    // Current state of modbus read registers
    eReadState: (WAIT_FOR_ENABLE, PREPARE_READ_REGS, EXECUTE_READ_REGS, WAIT_READ_REGS_FEEDBACK, ASSIGN_VALUES, SELECT_NEXT_SUBSYTEM, CON_COOL_DOWN, CON_LOCKOUT);
    // Select subsystem for request to prevent parallel requests
    eCurrentSubsystem: (INVERTER, METER, STORAGE);
END_VAR
VAR CONSTANT
    nInverterRegQuantity: WORD := 16;
    nInverterMBStartAddr: WORD := 40071;
    nMeterRegQuantity: WORD := 21;
    nMeterMBStartAddr: WORD := 40071;
    nStorageRegQuantity: WORD := 4;
    nStorageMBStartAddr: WORD := 40351;
    nConnectionCmBeforeLockout: INT := 5;
    nSubsystemCmBeforeLockout: INT := 2;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbReadRegister(sIPAddr := _sInverterIPAddr, nTCPPort := _nInverterTCPPort, tTimeout := _tConnectionTimeout);
fbConnectionCoolDown();

// Set ready state
bReady := eReadState <> CON_LOCKOUT;

// Default operating data has not been updated this cycle
stInverter.bOpDataIsUpdated := FALSE;
stMeter.bOpDataIsUpdated := FALSE;
stStorage.bOpDataIsUpdated := FALSE;

// State machine
CASE eReadState OF
    WAIT_FOR_ENABLE:
        IF bEnable AND fbConnectionCoolDown.Q THEN
            eReadState := CON_COOL_DOWN;
        ELSIF bEnable THEN
            eReadState := PREPARE_READ_REGS;
        END_IF

    PREPARE_READ_REGS:
        CASE eCurrentSubsystem OF
            INVERTER:
                fbReadRegister.nUnitID := _nInverterUnitID;
                fbReadRegister.nQuantity := nInverterRegQuantity;
                fbReadRegister.nMBAddr := nInverterMBStartAddr;
                fbReadRegister.cbLength := SIZEOF(stInverterRegisterData);
                fbReadRegister.pDestAddr := ADR(stInverterRegisterData);

            METER:
                fbReadRegister.nUnitID := _nMeterUnitID;
                fbReadRegister.nQuantity := nMeterRegQuantity;
                fbReadRegister.nMBAddr := nMeterMBStartAddr;
                fbReadRegister.cbLength := SIZEOF(stMeterRegisterData);
                fbReadRegister.pDestAddr := ADR(stMeterRegisterData);

            STORAGE:
                fbReadRegister.nUnitID := _nInverterUnitID;
                fbReadRegister.nQuantity := nStorageRegQuantity;
                fbReadRegister.nMBAddr := nStorageMBStartAddr;
                fbReadRegister.cbLength := SIZEOF(stStorageRegisterData);
                fbReadRegister.pDestAddr := ADR(stStorageRegisterData);
        END_CASE

        eReadState := EXECUTE_READ_REGS;

    EXECUTE_READ_REGS:
        fbReadRegister.bExecute := TRUE;
        fbConnectionCoolDown.IN := TRUE;
        eReadState := WAIT_READ_REGS_FEEDBACK;

    WAIT_READ_REGS_FEEDBACK:
        fbReadRegister.bExecute := FALSE;
        IF NOT fbReadRegister.bBusy THEN
            fbConnectionCoolDown.IN := FALSE;
            ConnectionErrorHandler();

            IF ConnectionLockoutIsActive() THEN
                // Lockout modbus connection
                eReadState := CON_LOCKOUT;
            ELSE
                eReadState := ASSIGN_VALUES;
            END_IF
        END_IF

    ASSIGN_VALUES:
        CASE eCurrentSubsystem OF
            INVERTER:
                stInverter.bOpDataIsUpdated := TRUE;
                stInverter.fCurrentL1 := Scale(stInverterRegisterData.nCurrentL1, stInverterRegisterData.nSfCurrent);
                stInverter.fCurrentL2 := Scale(stInverterRegisterData.nCurrentL2, stInverterRegisterData.nSfCurrent);
                stInverter.fCurrentL3 := Scale(stInverterRegisterData.nCurrentL3, stInverterRegisterData.nSfCurrent);
                stInverter.fVoltageL1L2 := Scale(stInverterRegisterData.nVoltageL1L2, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL2L3 := Scale(stInverterRegisterData.nVoltageL2L3, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL3L1 := Scale(stInverterRegisterData.nVoltageL3L1, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL1N := Scale(stInverterRegisterData.nVoltageL1N, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL2N := Scale(stInverterRegisterData.nVoltageL2N, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL3N := Scale(stInverterRegisterData.nVoltageL3N, stInverterRegisterData.nSfVoltage);
                stInverter.fPower := Scale(stInverterRegisterData.nPower, stInverterRegisterData.nSfPower);
                stInverter.fFrequency := Scale(stInverterRegisterData.nFrequency, stInverterRegisterData.nSfFrequency);

            METER:
                stMeter.bOpDataIsUpdated := TRUE;
                stMeter.fCurrentL1 := Scale(stMeterRegisterData.nCurrentL1, stMeterRegisterData.nSfCurrent);
                stMeter.fCurrentL2 := Scale(stMeterRegisterData.nCurrentL2, stMeterRegisterData.nSfCurrent);
                stMeter.fCurrentL3 := Scale(stMeterRegisterData.nCurrentL3, stMeterRegisterData.nSfCurrent);
                stMeter.fVoltageL1L2 := Scale(stMeterRegisterData.nVoltageL1L2, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL2L3 := Scale(stMeterRegisterData.nVoltageL2L3, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL3L1 := Scale(stMeterRegisterData.nVoltageL3L1, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL1N := Scale(stMeterRegisterData.nVoltageL1N, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL2N := Scale(stMeterRegisterData.nVoltageL2N, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL3N := Scale(stMeterRegisterData.nVoltageL3N, stMeterRegisterData.nSfVoltage);
                stMeter.fPower := Scale(stMeterRegisterData.nPower, stMeterRegisterData.nSfPower);
                stMeter.fPowerL1 := Scale(stMeterRegisterData.nPowerL1, stMeterRegisterData.nSfPower);
                stMeter.fPowerL2 := Scale(stMeterRegisterData.nPowerL2, stMeterRegisterData.nSfPower);
                stMeter.fPowerL3 := Scale(stMeterRegisterData.nPowerL3, stMeterRegisterData.nSfPower);
                stMeter.fFrequency := Scale(stMeterRegisterData.nFrequency, stMeterRegisterData.nSfFrequency);

            STORAGE:
                stStorage.bOpDataIsUpdated := TRUE;
                stStorage.nStateOfCharge := REAL_TO_INT(Scale(stStorageRegisterData.nStateOfCharge, stStorageRegisterData.nSfStateOfCharge));
                stStorage.eState := stStorageRegisterData.nState;
        END_CASE
        eReadState := SELECT_NEXT_SUBSYTEM;

    SELECT_NEXT_SUBSYTEM:
        CASE eCurrentSubsystem OF
            INVERTER:
                eCurrentSubsystem := METER;

            METER:
                eCurrentSubsystem := STORAGE;

            STORAGE:
                eCurrentSubsystem := INVERTER;

            ELSE
                eCurrentSubsystem := INVERTER;
        END_CASE
        eReadState := CON_COOL_DOWN;

    CON_COOL_DOWN:
        IF NOT bEnable THEN
            eReadState := WAIT_FOR_ENABLE;
        END_IF

        IF NOT fbConnectionCoolDown.Q THEN
            eReadState := PREPARE_READ_REGS;
        END_IF

    CON_LOCKOUT:
        (* Perform reset using Reset() function *)
END_CASE
]]></ST>
    </Implementation>
    <Method Name="ConnectionErrorHandler" Id="{eb35efc9-f4bd-48ca-9579-f04d9ee594f3}">
      <Declaration><![CDATA[METHOD PRIVATE ConnectionErrorHandler
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ConnectionLockoutIsActive() THEN
    RETURN;
END_IF

IF fbReadRegister.bError THEN
    // Apply countermeasure if ADS error occured
    CASE fbReadRegister.nErrId OF
        16#8001, // Modbus function not implemented
        16#8002, // Invalid address or length
        16#8003: // Invalid parameters: incorrect number of registers
            CASE eCurrentSubsystem OF
                INVERTER:
                    nInverterCountermeasure := nInverterCountermeasure + 1;
                METER:
                    nMeterCountermeasure := nMeterCountermeasure + 1;
                STORAGE:
                    nStorageCountermeasure := nStorageCountermeasure + 1;
            END_CASE
    
        16#8004,                                  // Modbus server error
        Global.E_TcSystemEventClass.TCPSendError, // TCP send error
        Tc2_System.E_AdsErr.CLIENT_SYNCTIMEOUT:   // Remote terminal is not responding in the specified ADS timeout
            nConnectionCountermeasure := nConnectionCountermeasure + 1;
            fbConnectionCoolDown.PT := _tConnectionCoolDown + _tConnectionCoolDown * LREAL_TO_INT(EXPT(nConnectionCountermeasure, 2));
    END_CASE

ELSE
    // Defer possibly still active countermeasure
    nInverterCountermeasure := 0;
    nMeterCountermeasure := 0;
    nStorageCountermeasure := 0;
    nConnectionCountermeasure := 0;

    // Reset connection cooldown timeout
    fbConnectionCoolDown.PT := _tConnectionCoolDown;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ConnectionLockoutIsActive" Id="{bf05b0a2-a100-4785-9923-1a19614766ee}">
      <Declaration><![CDATA[METHOD PRIVATE ConnectionLockoutIsActive : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nConnectionCountermeasure > nConnectionCmBeforeLockout OR nInverterCountermeasure > nSubsystemCmBeforeLockout OR nMeterCountermeasure > nSubsystemCmBeforeLockout OR nStorageCountermeasure > nSubsystemCmBeforeLockout OR eReadState = CON_LOCKOUT THEN
    ConnectionLockoutIsActive := TRUE;
ELSE
    ConnectionLockoutIsActive := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_Init" Id="{7814f5ef-9eb8-4cfe-966e-9c0030c1cf2b}">
      <Declaration><![CDATA[METHOD FB_Init: BOOL
VAR_INPUT
    // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInitRetains: BOOL;
    // TRUE: the instance will be copied to the copy code afterward (online change)
    bInCopyCode: BOOL;
    // IP address of the target device
    sInverterIPAddr: STRING;
    // Port number of the target device
    nInverterTCPPort: UINT;
    // Modbus RTU ID of inverter, value must be 16#FF if addressed directly via TCP/IP
    nInverterUnitID: BYTE;
    // Modbus RTU ID of meter, value must be 16#FF if addressed directly via TCP/IP
    nMeterUnitID: BYTE;
    // Timeout that may not be exceeded by execution of the ADS command
    tConnectionTimeout: TIME;
    // Timeout between modbus commands sent to target device
    tConnectionCoolDown: TIME;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Assign connection parameters
_sInverterIPAddr := sInverterIPAddr;
_nInverterTCPPort := nInverterTCPPort;
_nInverterUnitID := nInverterUnitID;
_nMeterUnitID := nMeterUnitID;
_tConnectionTimeout := tConnectionTimeout;
_tConnectionCoolDown := tConnectionCoolDown;

// Initialize connection cooldown timeout
IF bInitRetains THEN
    fbConnectionCoolDown.PT := tConnectionCoolDown;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{dcc751c1-95e6-4506-87cb-37fdf657bcaf}">
      <Declaration><![CDATA[METHOD PUBLIC Reset
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nInverterCountermeasure := 0;
nMeterCountermeasure := 0;
nStorageCountermeasure := 0;
nConnectionCountermeasure := 0;

eReadState := WAIT_FOR_ENABLE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Scale" Id="{42cdecb6-346c-42d7-8d00-085967a56f85}">
      <Declaration><![CDATA[METHOD PRIVATE Scale : REAL
VAR_INPUT
    nValue: WORD;
    nScaleFactor: WORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Scale := nValue * LREAL_TO_REAL(EXPT(10, UINT_TO_INT(nScaleFactor)));
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>