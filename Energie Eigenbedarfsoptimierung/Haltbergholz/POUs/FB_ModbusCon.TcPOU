<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_ModbusCon" Id="{43065017-eb91-4d51-b9c6-b54abe313361}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_ModbusCon
VAR_INPUT
    bEnable: BOOL;
END_VAR
VAR_OUTPUT
    // Operating data from inverter
    stInverter: ST_OpDataInverter;
    // Operating data from meter
    stMeter: ST_OpDataMeter;
    // Operating data from storage
    stStorage: ST_OpDataStorage;
    // Connection is ready and not locked out
    bReady: BOOL;
END_VAR
VAR
    // IP address of the target device
    _sInverterIPAddr: STRING;
    // Port number of the target device
    _nInverterTCPPort: UINT;
    // Modbus RTU ID of inverter, value must be 16#FF if addressed directly via TCP/IP
    _nInverterUnitID: BYTE;
    // Modbus RTU ID of meter, value must be 16#FF if addressed directly via TCP/IP
    _nMeterUnitID: BYTE;
    // Timeout that may not be exceeded by execution of the ADS command
    _tConnectionTimeout: TIME;
    // Timeout between modbus commands sent to target device
    _tConnectionCoolDown: TIME;

    // Modbus connection to read registers
    fbReadRegister: FB_MBReadRegs;
    // Connection cooldown timeout between requests
    fbConnectionCoolDown: TOF;

    // Register data of inverter
    stInverterRegisterData: ST_RegMapInverter;
    // Register data of meter
    stMeterRegisterData: ST_RegMapMeter;
    // Register data of storage
    stStorageRegisterData: ST_RegMapStorage;

    // Number of current tried countermeasures after modbus connection error
    nConnectionCountermeasure: INT;
    // Number of current tried countermeasures after modbus request error regarding inverter
    nInverterCountermeasure: INT;
    // Number of current tried countermeasures after modbus request error regarding meter
    nMeterCountermeasure: INT;
    // Number of current tried countermeasures after modbus request error regarding storage
    nStorageCountermeasure: INT;

    // Current state of modbus read registers
    eReadState: (WAIT_FOR_ENABLE, PREPARE_READ_REGS, EXECUTE_READ_REGS, WAIT_READ_REGS_FEEDBACK, ASSIGN_VALUES, SELECT_NEXT_SUBSYTEM, CON_COOL_DOWN, CON_LOCKOUT);
    // Select subsystem for request to prevent parallel requests
    eCurrentSubsystem: (INVERTER, METER, STORAGE);
END_VAR
VAR CONSTANT
    // Number of output registers used by stInverterRegisterData
    nInverterRegQuantity: WORD := 16;
    // Start address of the output register used by stInverterRegisterData
    nInverterMBStartAddr: WORD := 40071;
    // Number of output registers used by stMeterRegisterData
    nMeterRegQuantity: WORD := 21;
    // Start address of the output register used by stMeterRegisterData
    nMeterMBStartAddr: WORD := 40071;
    // Number of output registers used by stStorageRegisterData
    nStorageRegQuantity: WORD := 4;
    // Start address of the output register used by stStorageRegisterData
    nStorageMBStartAddr: WORD := 40351;
    // Number of attempted countermeasures before connection lockout (connection error)
    nConnectionCmBeforeLockout: INT := 5;
    // Number of attempted countermeasures before connection lockout (subsystem error)
    nSubsystemCmBeforeLockout: INT := 2;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbReadRegister(sIPAddr := _sInverterIPAddr, nTCPPort := _nInverterTCPPort, tTimeout := _tConnectionTimeout);
fbConnectionCoolDown();

// Set ready state
bReady := eReadState <> CON_LOCKOUT;

// Default operating data has not been updated this cycle
stInverter.bOpDataIsUpdated := FALSE;
stMeter.bOpDataIsUpdated := FALSE;
stStorage.bOpDataIsUpdated := FALSE;

// State machine
CASE eReadState OF
    WAIT_FOR_ENABLE:
        IF bEnable AND fbConnectionCoolDown.Q THEN
            eReadState := CON_COOL_DOWN;
        ELSIF bEnable THEN
            eReadState := PREPARE_READ_REGS;
        END_IF

    PREPARE_READ_REGS:
        CASE eCurrentSubsystem OF
            INVERTER:
                fbReadRegister.nUnitID := _nInverterUnitID;
                fbReadRegister.nQuantity := nInverterRegQuantity;
                fbReadRegister.nMBAddr := nInverterMBStartAddr;
                fbReadRegister.cbLength := SIZEOF(stInverterRegisterData);
                fbReadRegister.pDestAddr := ADR(stInverterRegisterData);

            METER:
                fbReadRegister.nUnitID := _nMeterUnitID;
                fbReadRegister.nQuantity := nMeterRegQuantity;
                fbReadRegister.nMBAddr := nMeterMBStartAddr;
                fbReadRegister.cbLength := SIZEOF(stMeterRegisterData);
                fbReadRegister.pDestAddr := ADR(stMeterRegisterData);

            STORAGE:
                fbReadRegister.nUnitID := _nInverterUnitID;
                fbReadRegister.nQuantity := nStorageRegQuantity;
                fbReadRegister.nMBAddr := nStorageMBStartAddr;
                fbReadRegister.cbLength := SIZEOF(stStorageRegisterData);
                fbReadRegister.pDestAddr := ADR(stStorageRegisterData);
        END_CASE

        eReadState := EXECUTE_READ_REGS;

    EXECUTE_READ_REGS:
        fbReadRegister.bExecute := TRUE;
        fbConnectionCoolDown.IN := TRUE;
        eReadState := WAIT_READ_REGS_FEEDBACK;

    WAIT_READ_REGS_FEEDBACK:
        fbReadRegister.bExecute := FALSE;
        IF NOT fbReadRegister.bBusy THEN
            fbConnectionCoolDown.IN := FALSE;
            ConnectionErrorHandler();

            IF ConnectionLockoutIsActive() THEN
                // Lockout modbus connection
                eReadState := CON_LOCKOUT;
            ELSE
                eReadState := ASSIGN_VALUES;
            END_IF
        END_IF

    ASSIGN_VALUES:
        CASE eCurrentSubsystem OF
            INVERTER:
                stInverter.bOpDataIsUpdated := TRUE;
                stInverter.fCurrentL1 := Scale(stInverterRegisterData.nCurrentL1, stInverterRegisterData.nSfCurrent);
                stInverter.fCurrentL2 := Scale(stInverterRegisterData.nCurrentL2, stInverterRegisterData.nSfCurrent);
                stInverter.fCurrentL3 := Scale(stInverterRegisterData.nCurrentL3, stInverterRegisterData.nSfCurrent);
                stInverter.fVoltageL1L2 := Scale(stInverterRegisterData.nVoltageL1L2, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL2L3 := Scale(stInverterRegisterData.nVoltageL2L3, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL3L1 := Scale(stInverterRegisterData.nVoltageL3L1, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL1N := Scale(stInverterRegisterData.nVoltageL1N, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL2N := Scale(stInverterRegisterData.nVoltageL2N, stInverterRegisterData.nSfVoltage);
                stInverter.fVoltageL3N := Scale(stInverterRegisterData.nVoltageL3N, stInverterRegisterData.nSfVoltage);
                stInverter.fPower := Scale(stInverterRegisterData.nPower, stInverterRegisterData.nSfPower);
                stInverter.fFrequency := Scale(stInverterRegisterData.nFrequency, stInverterRegisterData.nSfFrequency);

            METER:
                stMeter.bOpDataIsUpdated := TRUE;
                stMeter.fCurrentL1 := Scale(stMeterRegisterData.nCurrentL1, stMeterRegisterData.nSfCurrent);
                stMeter.fCurrentL2 := Scale(stMeterRegisterData.nCurrentL2, stMeterRegisterData.nSfCurrent);
                stMeter.fCurrentL3 := Scale(stMeterRegisterData.nCurrentL3, stMeterRegisterData.nSfCurrent);
                stMeter.fVoltageL1L2 := Scale(stMeterRegisterData.nVoltageL1L2, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL2L3 := Scale(stMeterRegisterData.nVoltageL2L3, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL3L1 := Scale(stMeterRegisterData.nVoltageL3L1, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL1N := Scale(stMeterRegisterData.nVoltageL1N, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL2N := Scale(stMeterRegisterData.nVoltageL2N, stMeterRegisterData.nSfVoltage);
                stMeter.fVoltageL3N := Scale(stMeterRegisterData.nVoltageL3N, stMeterRegisterData.nSfVoltage);
                stMeter.fPower := Scale(stMeterRegisterData.nPower, stMeterRegisterData.nSfPower);
                stMeter.fPowerL1 := Scale(stMeterRegisterData.nPowerL1, stMeterRegisterData.nSfPower);
                stMeter.fPowerL2 := Scale(stMeterRegisterData.nPowerL2, stMeterRegisterData.nSfPower);
                stMeter.fPowerL3 := Scale(stMeterRegisterData.nPowerL3, stMeterRegisterData.nSfPower);
                stMeter.fFrequency := Scale(stMeterRegisterData.nFrequency, stMeterRegisterData.nSfFrequency);

            STORAGE:
                stStorage.bOpDataIsUpdated := TRUE;
                stStorage.nStateOfCharge := REAL_TO_INT(Scale(stStorageRegisterData.nStateOfCharge, stStorageRegisterData.nSfStateOfCharge));
                stStorage.eState := stStorageRegisterData.nState;
        END_CASE
        eReadState := SELECT_NEXT_SUBSYTEM;

    SELECT_NEXT_SUBSYTEM:
        CASE eCurrentSubsystem OF
            INVERTER:
                eCurrentSubsystem := METER;

            METER:
                eCurrentSubsystem := STORAGE;

            STORAGE:
                eCurrentSubsystem := INVERTER;

            ELSE
                eCurrentSubsystem := INVERTER;
        END_CASE
        eReadState := CON_COOL_DOWN;

    CON_COOL_DOWN:
        IF NOT bEnable THEN
            eReadState := WAIT_FOR_ENABLE;
        END_IF

        IF NOT fbConnectionCoolDown.Q THEN
            eReadState := PREPARE_READ_REGS;
        END_IF

    CON_LOCKOUT:
        (* Perform reset using Reset() function *)
END_CASE
]]></ST>
    </Implementation>
    <Folder Name="Properties" Id="{e526952d-1a01-4e02-a2fb-614c560a061a}" />
    <Method Name="ConnectionErrorHandler" Id="{eb35efc9-f4bd-48ca-9579-f04d9ee594f3}">
      <Declaration><![CDATA[METHOD PRIVATE ConnectionErrorHandler
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ConnectionLockoutIsActive() THEN
    RETURN;
END_IF

IF fbReadRegister.bError THEN
    // Apply countermeasure if ADS error occured
    CASE fbReadRegister.nErrId OF
        16#8001, // Modbus function not implemented
        16#8002, // Invalid address or length
        16#8003: // Invalid parameters: incorrect number of registers
            CASE eCurrentSubsystem OF
                INVERTER:
                    nInverterCountermeasure := nInverterCountermeasure + 1;
                METER:
                    nMeterCountermeasure := nMeterCountermeasure + 1;
                STORAGE:
                    nStorageCountermeasure := nStorageCountermeasure + 1;
            END_CASE
    
        16#8004,                                  // Modbus server error
        Global.E_TcSystemEventClass.TCPSendError, // TCP send error
        Tc2_System.E_AdsErr.CLIENT_SYNCTIMEOUT:   // Remote terminal is not responding in the specified ADS timeout
            nConnectionCountermeasure := nConnectionCountermeasure + 1;
            fbConnectionCoolDown.PT := _tConnectionCoolDown + _tConnectionCoolDown * LREAL_TO_INT(EXPT(nConnectionCountermeasure, 2));
    END_CASE

ELSE
    // Defer possibly still active countermeasure
    nInverterCountermeasure := 0;
    nMeterCountermeasure := 0;
    nStorageCountermeasure := 0;
    nConnectionCountermeasure := 0;

    // Reset connection cooldown timeout
    fbConnectionCoolDown.PT := _tConnectionCoolDown;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ConnectionLockoutIsActive" Id="{bf05b0a2-a100-4785-9923-1a19614766ee}">
      <Declaration><![CDATA[METHOD PRIVATE ConnectionLockoutIsActive : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nConnectionCountermeasure > nConnectionCmBeforeLockout OR nInverterCountermeasure > nSubsystemCmBeforeLockout OR nMeterCountermeasure > nSubsystemCmBeforeLockout OR nStorageCountermeasure > nSubsystemCmBeforeLockout OR eReadState = CON_LOCKOUT THEN
    ConnectionLockoutIsActive := TRUE;
ELSE
    ConnectionLockoutIsActive := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="nInverterTCPPort" Id="{0208614e-59f7-4633-83e9-f19d97c40446}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY nInverterTCPPort : UINT]]></Declaration>
      <Get Name="Get" Id="{0751807e-b515-449a-81b0-294d4ae71c2d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nInverterTCPPort := _nInverterTCPPort;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{73510e41-675d-4b24-b148-178637450bd3}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_nInverterTCPPort := nInverterTCPPort;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="nInverterUnitID" Id="{4b091f00-d0cf-42a0-8a80-698bd7c0cb80}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY nInverterUnitID : BYTE]]></Declaration>
      <Get Name="Get" Id="{203f77d2-9bd0-44e9-b1f5-d0e6a98b84c1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nInverterUnitID := _nInverterUnitID;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{13d50004-a553-4bfb-a6c8-e2e4794064b3}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_nInverterUnitID := nInverterUnitID;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="nMeterUnitID" Id="{527b1d04-a12e-4bee-93ec-d9b28a6a9926}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY nMeterUnitID : BYTE]]></Declaration>
      <Get Name="Get" Id="{a4b3b186-664a-4b6a-ac57-3ad93c32bb74}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nMeterUnitID := _nMeterUnitID;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{3c2feef1-2f4b-477a-b581-ec4705605620}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_nMeterUnitID := nMeterUnitID;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="Reset" Id="{dcc751c1-95e6-4506-87cb-37fdf657bcaf}">
      <Declaration><![CDATA[METHOD PUBLIC Reset
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nInverterCountermeasure := 0;
nMeterCountermeasure := 0;
nStorageCountermeasure := 0;
nConnectionCountermeasure := 0;

eReadState := WAIT_FOR_ENABLE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Scale" Id="{42cdecb6-346c-42d7-8d00-085967a56f85}">
      <Declaration><![CDATA[METHOD PRIVATE Scale : REAL
VAR_INPUT
    nValue: WORD;
    nScaleFactor: WORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Scale := nValue * LREAL_TO_REAL(EXPT(10, UINT_TO_INT(nScaleFactor)));
]]></ST>
      </Implementation>
    </Method>
    <Property Name="sInverterIPAddr" Id="{bb6c70b4-566d-44aa-9bf4-f7634820c67a}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY sInverterIPAddr : STRING]]></Declaration>
      <Get Name="Get" Id="{898b2f55-6363-49f6-b4cc-12a33e04db4b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sInverterIPAddr := _sInverterIPAddr;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{c27586e5-8cd9-4e3e-ac15-5a3ff0e940de}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_sInverterIPAddr := sInverterIPAddr;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="tConnectionCoolDown" Id="{6f8307c1-4b4e-402e-9adb-89621f0deb8a}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY tConnectionCoolDown : TIME]]></Declaration>
      <Get Name="Get" Id="{7e0cee8a-5fc2-457f-8bf4-bf2545934b94}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[tConnectionCoolDown := _tConnectionCoolDown;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{a4cab1d9-c121-4bcb-a3ec-859f2ad4656e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_tConnectionCoolDown := tConnectionCoolDown;

// Apply connection cooldown timeout if no counter measure is active
IF nConnectionCountermeasure = 0 AND nInverterCountermeasure = 0 AND nMeterCountermeasure = 0 AND nStorageCountermeasure = 0 THEN
    fbConnectionCoolDown.PT := tConnectionCoolDown;
END_IF
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="tConnectionTimeout" Id="{e5048373-5545-4343-bd36-b4a6dfb3f32d}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY tConnectionTimeout : TIME]]></Declaration>
      <Get Name="Get" Id="{1a2f3e9b-eb8a-4180-b874-494a0b9ca5aa}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[tConnectionTimeout := _tConnectionTimeout;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{afb1dd33-6454-4ce6-a3e7-ff21ccd34cf4}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_tConnectionTimeout := tConnectionTimeout;
]]></ST>
        </Implementation>
      </Set>
    </Property>
  </POU>
</TcPlcObject>